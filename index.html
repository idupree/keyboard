<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>human input device</title>
<style>
/* CSS reset */
article,aside,figure,footer,header,hgroup,menu,nav,section{display:block;}
html,body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,select,p,blockquote,th,td{margin:0;padding:0;border:0}
h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:inherit;}
img{color:transparent;font-size:0;border:0;vertical-align:middle;}
abbr[title]{border-bottom:dotted 1px;}
button{font:inherit;line-height:inherit;text-align:inherit;text-decoration:none;text-indent:0}

.kb {
  width: 1280px;
  height: 689px;
  background-color: #fcd;
  margin: auto;
}
.key {
  display: inline-block;
  min-width: 95px;
  min-height: 55px;
  margin: 5px;
  color: #222;
  background-color: #f9f9f9;
  text-align: center;
  vertical-align: middle;
  text-decoration: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.001s;
}
.key:active {
  background-color: #ddd;
}
html, body {
  overflow: hidden;
}
</style>
<body>
<script>
+function(){
"use strict";
var rows = [
  ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12'],
  ['Esc', 'back', 'forward', 'reload', 'cut', 'copy', 'paste', 'undo', 'redo'],
  ['?', '{', '}', '[', ']', '/', '\\', '|', '<', '>', ':', '"'],
  ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+'],
  ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '='],
  ['Tab', '`', 'Home', 'End', 'PgUp', 'PgDn', 'Delete', 'Left', 'Down', 'Up', 'Right'],
  ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'Enter'],
  ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\''],
  ['Shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', 'Shift'],
  ['Ctrl', 'Alt', 'space']
  ];

// keyname: true for keys that are currently pressed down
var activatedKeys = {};

var cachebuster = function() {
  return '' + Date.now() + Math.random();
}

var $statusarea = document.createElement('div');
$statusarea.className = 'statusarea';

// TODO if queued things are too old, stop trying them
// TODO server-side, unpress keys when connection issues
// TODO: per queue-item padding to equal size, and random dummy packets?
var queue = [];
var inflight_queue = null;

var logStr = 'begin';
$statusarea.textContent = logStr;
var doLog = function(s) {
  logStr += '; ' + s;
  logStr = logStr.slice(-100);
  $statusarea.textContent = logStr;
};

var retrySendQueue = function() {
  setTimeout(function() {
    queue = [].concat(inflight_queue, queue);
    inflight_queue = null;
    trySendQueue();
  }, 1250);
};
var trySendQueue = function() {
  if(queue.length === 0) {
    return;
  }
  if(inflight_queue) {
    return;
  }
  var req = new XMLHttpRequest();
  req.onreadystatechange = function() {
    if(req.readyState === 4) { // complete
      if(req.status === 200 || req.status === 204) {
        console.log("yay");
        inflight_queue = null;
        doLog('done.');
        trySendQueue();
      } else {
        console.log("boo!", req.status);
        doLog('failed.');
      }
    }
  };
  req.error = function() {
    doLog('err-retry.');
    retrySendQueue();
  };
  req.timeout = 6000;
  req.ontimeout = function() {
    doLog('timeout-retry.');
    retrySendQueue();
  };
  req.open('POST', '/magic?'+cachebuster(), true);
  req.setRequestHeader('X-Not-Cross-Domain', 'yes');
  //req.setRequestHeader('X-Token', localStorage["authtoken"]);
  //req.setRequestHeader('X-Command', command);
  req.setRequestHeader('Content-Type', 'application/json');
  var body = {"InputEvents": queue};
  inflight_queue = queue;
  queue = [];
  req.send(JSON.stringify(body));
};

//..hmm what if keyup gets there before keydown..

// mouseup can be on the wrong element and doesn't work with touch
// simpler: hackily use the transitionend event to detect CSS's
// perfect :active logic!
// ...not quite perfect. Not for multiple touches at once on ChromeOS.
// Also preventDefault on long touches on ChromeOS is important here
// (stop rightclick menu, which is both the goal and sad).
var keyActiveChange = function(keyElem, keyName, isDown) {
  var wasDown = !!activatedKeys[keyName];
  var isDown = !!isDown;
  if(isDown) {
    activatedKeys[keyName] = true;
  } else {
    delete activatedKeys[keyName];
  }
  if(isDown !== wasDown) {
    var action = (isDown ? 'keydn' : 'keyup');
    queue.push({"Action": action, "Key": keyName});
    trySendQueue();
  //TODO hilight key
    keyElem.style.color = (isDown ? '#f00' : '#0f0');

    //$statusarea.textContent = keyName + " " + (isDown ? "down" : "up");
    doLog(keyName + " " + (isDown ? "down" : "up"));
  }
};
var transitionEvent = function(e) {
  e.preventDefault();
  e.stopPropagation();
  var keyElem = e.target;
  var down = keyElem.matches(':active');
  var key = keyElem.dataAction;
  keyActiveChange(keyElem, key, down);
};
//TODO events bind to body not a?
var touchEvent = function(e) {
  e.preventDefault();
  e.stopPropagation();
  var touches = e.changedTouches;
  for(var i = 0; i < touches.length; i++) {
    var touch = touches[i];
    var keyElem = touch.target;
    var key = keyElem.dataAction;
    if(key) {
    if(e.type === 'touchstart') {
      keyActiveChange(keyElem, key, true);
    }
    if(e.type === 'touchend' || e.type === 'touchcancel') {
      keyActiveChange(keyElem, key, false);
    }
    }
  }
};
var $kb = document.createElement('div');
$kb.className = 'kb';
$kb.addEventListener('touchstart', touchEvent);
$kb.addEventListener('touchend', touchEvent);
$kb.addEventListener('touchcancel', touchEvent);
$kb.addEventListener('touchmove', touchEvent);
for(var r = 0; r < rows.length; r++) {
  var row = rows[r];
  var $row = document.createElement('div');
  $row.className = 'row';
  for(var c = 0; c < row.length; c++) {
    var key = row[c];
    var $key = document.createElement('button');
    $key.className = 'key';
    $key.textContent = key;
    $key.dataAction = key;
    //$key.addEventListener('mousedown', keyDown);
    //$key.addEventListener('mouseup', keyUp);
    //not implemented in Chrome, it seems: $key.addEventListener('transitionstart', transitionStart);
    $key.addEventListener('transitionend', transitionEvent);
    $row.appendChild($key);
  }
  $kb.appendChild($row);
}
document.body.appendChild($kb);

$kb.appendChild($statusarea);

}();
</script>
